/*
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 *** Function:	zopenc_(pfd,pfname,pnewfl,pnerr,pfnlen)

 *** Purpose:	Open and/or create a file for efficient I/O.

 *** Inputs:	pfd	Address where negated file descriptor will be stored
		pfname	Pointer to file name
		pnerr	Address where error code will be stored
		pnewfl  Pointer to create if necessary flag
                pro     Pointer to read-only flag
		pfnlen	Length of pfname including trailing blanks (this
			paramter is automatically generated by FORTRAN)

 *** Returns:	pfd	See Inputs.
		pnerr	See Inputs.
                = 0 ok
                = 1 insufficient access rights to open/create file.
                = 2 some other error occurred during open/create.

 *** Notes:	SAC carries around FORTRAN logical unit numbers, but it
		doesn't currently have hooks for "C" file descriptors.
		Therefore, the "C" descriptors are carried in the same
		variable as the logical unit numbers.  The file descriptors
		are negated to distinguish them from logical unit numbers.

 *** History:	07/29/98  Moved string-length-specifier to the rear of the 
			  parameter list, and added stub with an underscore
			  (zopenc_) for FORTRAN compatibility.  maf
		12/16/85  Tested--D. Trimmer
                05/26/87  Merged MASSCOMP differences in current version--J. Tull
                07/29/87  Added read-only flag--J. Tull
                07/31/87  Added check for insufficient access rights--J.Tull

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <sys/types.h>
#include <sys/stat.h>


#ifdef BSD4_2
#include <sys/file.h>
#else
#include <fcntl.h>
#endif
#include <errno.h>


void zopenc(pfd,pfname,pnewfl,pro,pnerr,pfnlen)
int *pfd;		/* address to store file descriptor */
char pfname[];		/* file name */
int *pnewfl;		/* create if necessary flag */
int *pro;              /* read-only flag */
int *pnerr;		/* address to store error code */
int pfnlen;            /* length of file name from F77 */
{
    int i;
    int mode;
    char fname[BUFSIZ];

    *pnerr=0;
    if(*pro) {
	    mode=O_RDONLY;
    }
    else {
	    mode=O_RDWR;
    }

    if ( pfnlen > strlen( pfname ) ) {
	    pfnlen = strlen( pfname ) ;
    }

    for(i=0;i<BUFSIZ && i<pfnlen;++i) {
	    fname[i] = pfname[i];
    }
    for(--i;((fname[i]==' ') || (fname[i]=='\0')) && i>0;--i);  /* get rid of trailing blanks */
    fname[i+1]='\0';

    if(*pnewfl)
	*pfd = creat ( fname , 0 ) ; /* create file */
    else
	*pfd=open(fname,mode, 0) ; /* open file */

    if ( *pfd < 0 )
    {
        if(errno == EACCES) {
            *pnerr=1;
        }
        else {
            *pnerr=2;
        }
    }

    if(*pnewfl && *pnerr == 0)
	chmod(fname,0666);			/* set file permissions */

    *pfd = -(*pfd);			/* see Notes above */
    return;
}





void zopenc_(pfd,pfname,pnewfl,pro,pnerr,pfnlen)
int *pfd;               /* address to store file descriptor */
char pfname[];          /* file name */
int *pnewfl;           /* create if necessary flag */
int *pro;              /* read-only flag */
int *pnerr;             /* address to store error code */
int pfnlen;            /* length of file name from F77 */
{
	zopenc(pfd,pfname,pnewfl,pro,pnerr,pfnlen) ;
}
