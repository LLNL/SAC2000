#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <strings.h>
#include "complex.h"
#include "proto.h"
#include "mach.h"
#include "msg.h"
#include "icm.h"
#include "wtofd.h"
#include "hdr.h"
void  levinD(double* r, float* a, float* reflct, int n);

void getResponse ( float *array , int order , float gain ,
			char *kprefix , int *nerr ) ;
/*                                                           PREWIT
 *
 *  Prewhitens an input sequence in-place.  Uses a low-order prediction error
 *    filter. Order selected for stability if needed.
 *
 *  Author:  George Randall after Dave Harris
 *
 *  Created: February 12, 1986
 *
 *  Last Modified:  February 12, 1986
 *                  July 7, 1998.  maf
 *
 *  Input arguments:
 *  ----- ----------
 *
 *    DATA                 REAL*4 array containing input sequence - contains
 *                         prewhitened sequence upon exit from this routine.
 *
 *    #SAMPLES             Number of data points in sequence.
 *
 *    PREDICTOR_ORDER      Order of prediction filter used to prewhiten
 *                         sequence. Truncated for stability
 *
 *  Output Arguments:
 *  ------ ----------
 *
 *    DATA                 As above.
 *
 *    ARRAY                Array of prewhitening filter coefficients.
 *
 *    ERROR_MESSAGE        CHARACTER*130 variable containing error message if
 *                         error is detected.  Equal to ' ' if no errors.
 *
 *  Linkage:     DIRCOR, LEVIN, PEF
 *
 * */
#define	NCMAX	12

void /*FUNCTION*/ prewit( data, nsamps, order, array, kprefix, errmsg )
float data[];
int nsamps, *order;
float array[];
char *kprefix, *errmsg;
{
	char temp[ 51 ] ;
	int idx, jdx, j2, kdx, kb, torder;
	float at, atemp[NCMAX], q, reflct[NCMAX + 1], sa[NCMAX + 1] ;
	double cor[NCMAX] ;

	float *const Array = &array[0] - 1;
	float *const Atemp = &atemp[0] - 1;
	float *const Reflct = &reflct[0] - 1;
	float *const Sa = &sa[0] - 1;




	/*  Initializations
	 * */
	errmsg[ 0 ] = temp[ 0 ] = '\0' ;

	/*  Range check for predictor order
	 * */
	if( *order < 1 || *order > NCMAX ){
            strcpy( errmsg,
                   "*** PREWIT  -  Predictor order out of bounds (1-12) ***" );
	}

	/*  Design the prewhitening filter
	 * */
	dircor( data, data, nsamps, 0, *order + 1, cor );
	levinD( cor, array, reflct, *order + 1 );

	/*  Check for stability, and truncate filter if necessary
	 *  so the recursive de-whitener is safely stable
	 *  Use an adaptation of LPTRN code from Markel and Gray
	 *  found in the IEEE ASSP book of signal processing codes
	 * */
	torder = *order;
	/*	do 100 i = NCMAX+1, 1, -1
	 *	  if ( abs( reflct(i) ) .gt. 0.95 ) torder = i - 1
	 * 100    continue
	 *
	 *  If any reflection coefficients are too close to +1 or -1
	 *  then the system is getting dangerous, so truncate, and
	 *  then regenerate the filter coeffs for the truncated filter
	 * */
	if( torder != *order ){
	    for( idx = 1; idx <= torder; idx++ ){
		Sa[idx] = Reflct[idx];
	    }
	    for( jdx = 2; jdx <= torder; jdx++ ){
		j2 = jdx/2;
		q = Reflct[jdx];
		for( kdx = 1; kdx <= j2; kdx++ ){
		    kb = jdx - kdx;
		    at = Sa[kdx] + q*Sa[kb];
		    Sa[kb] = Sa[kb] + q*Sa[kdx];
		    Sa[kdx] = at;
		}
	    }
	    for( idx = 1; idx <= torder; idx++ ){
		Array[idx + 1] = Sa[idx];
	    }
	    for( idx = torder + 2; idx <= (*order + 1); idx++ ){
		Array[idx] = 0.;
	    }
	    Array[1] = 1.;
	    *order = torder;
	}

	/*  Prewhiten the data
	 *
	 *    Negate coefficients of prediction error filter generated by LEVIN.
	 *    For historical reasons, different storage modes are used in LEVIN
	 *    and PEF.
	 * */
	for( idx = 1; idx <= *order; idx++ ){
	    Atemp[idx] = -Array[idx + 1];
	}

	pef( data, nsamps, atemp, *order, 0, 0., data, temp );
	if( temp[ 0 ] ){
	    strcat( errmsg, temp ) ;
	    strcat( errmsg, " from (PREWIT)" ) ;
	}


	/* If filterdesign option is requested, do that now */
	if ( cmicm.lfd ) {
	    int nerr ;
	    double gain, gainSqr = 0.0 ;

	    /* Determine the gain of the system. */
	    /* G*G = r[0] + sum( a[k] * r[k] )   where 1 <= k <= *order
	       since a[0] always equals 1, it can be written as
	       G*G = sum( a[k] * r[k] )  where 0 <= k <= *order */
	    for ( idx = 0 ; idx <= *order ; idx++ )
		gainSqr += (double)array[ idx ] * cor[ idx ] ;

	    gain = sqrt ( gainSqr ) ;

	    if( isNaN ( (float) gain ) ) {
		nerr = 1620 ;
		setmsg( "WARNING" , nerr ) ;
		apcmsg( kprefix , strlen( kprefix ) + 1 ) ;
		outmsg() ;
		clrmsg() ;
	    }
		
	    else {
		/* Determine digital frequency response,
		   (amplitude, frequency, and gd) */
		getResponse( array , *order , (float) gain, kprefix , &nerr ) ; 
		if ( nerr ) {
		    setmsg ( "ERROR" , nerr ) ;
		    outmsg () ;
		    clrmsg () ;
		}
	    }

	} /* end if ( cmspe.lfd ) */

} /* end of function */

